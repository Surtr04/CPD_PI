\subsection{Parallelism Oportunities}
\label{sec:220}

A typical approach to parallelism in stencil algorithms is based on the premiss that a given point of the domain can be computed once the surrounding points (its dependencies) are ready.
Due to this being a first order algorithm, these dependencies are extremelly local (computations for a cell depend only on the immediatelly adjacent edges, and vice-versa).
Theorectically, this should the basis for the parallelism strategy: mesh subsets can be computed once their directly connected elements are up-to-date, even though other unrelated mesh subsets would possibly be in an older state.
Yet, this approach 


% Due to being a first order algorithm, data dependencies are extremelly local (computations for a cell depend only on the immediatelly adjacent edges, and the same applies for flux computation) and this could provide a possibility to explore other, less homogeneous parallelism approaches. 
% Given that, for a subset of the mesh, if its directly connected elements are already up-to-date, the values for this subset could be computed (either flux or pollution update), even though other nonrelated subsets would possibly still be in an older state. 

Theoretically, this should the basis of a alternative approach for this algorithm, especially in a distributed memory implementation. However, that approach also adds a higher degree of complexity, and involves deep changes to the underlying algorithm itself. As the purpose of this document is not to study better alternative algorithms to solve the problem \polu is aimed at, this approach was not developped.

During \polu's main loop both core functions, \computeflux and \update, depend on each other to perform their tasks. \update requires flux from all edges to be previously computed in \computeflux, which in turn requires that all pollution values are up-to-date to correctly compute the flux for the next iteration. This creates two implicit synchronization points in the main loop, and is a consequence of the heartbeat characteristics of the problem.

Since parallelization of both tasks is therefore impossible, both functions can be looked at as individual tasks, which may be subject to distinct individual parallelization approaches.
