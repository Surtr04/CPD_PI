\subsection{Original}
\label{sec:310}
%\todo[inline,color=blue!40]{Add some algebra to the core functions text. Hard to keep track with only text.}

The original \polu program was implemented using structures as \textit{Arrays-Of-Pointers} (AOP). While this allows for an easier development and better code readability, the deep levels of dereferencing imply an increased number of memory accesses, which aggravate the effects of any memory bottlenecks.

In this original version, the \computeflux function iterates over each edge, and loads the pollution levels and velocity vectors of the cells it connects. For edges in the border of the mesh, a convention is followed, indicating that the non existing cell is alwasy the right one (cells are refered to as left and right cells of a given edge). When the right cell doesn't exist, the \dirichlet condition is used as the value for that border.

The velocity vector in the edge is computed based on the velocity of both cells and the normal of the edge. This final velocity also gives information about the direction of the flux. A positive velocity makes the pollution flow from left to right, and the inverse happens with a negative velocity. \Cref{alg:flux} illustrates this behavious.



\begin{figure}[!htp]
	\begin{alg}
		\ForAll {$edge \in Edges$}				\\
			$l     \gets left\_cells_{edge}$ 	\\
			$r     \gets rigth\_cells_{edge}$ 	\\
			$u_{l} \gets pollution_{l}$ 		
			\If {$\exists Cells_{r}$} 			\\
				$u_{r} \gets pollution_{r}$
			\Else 								\\
				$u_{r} \gets \dirichlet$ 
			\EndIf 	 							\\
			$v_{edge} \gets (v_{l} + v_{r}) / 2 \cdot normal_{edge}$ 					\\
			$v_{max} \gets max(v_{max}, v_{edge})$ 										\\
			$flux_{edge} += u_{l} \cdot [v_{edge}]^{+} + u_{r} \cdot [v_{edge}]^{-}$
		\EndFor
	\end{alg}

	\caption{Pseudocode for the original \computeflux function}
	\label{alg:flux}
\end{figure}

This function also returns the elapsed time, which is computed with the maximum absolute value of the computed edge velocities, and is used at the end of the iteration to keep track of the total elapsed time.

The original \update function also iterates over each edge. The contribution of each edge to the cells final value is computed as the product between the elapsed time, the computed flux and the ratio between the edge's length and the cell's area. This is described in \cref{alg:update}.

\begin{figure}[!htp]
	\begin{alg}
		\ForAll {$edge \in Edges$}

			$\Delta{u} \gets \Delta{t} \cdot flux_{edge} \cdot L_{edge}$

			$l \gets left\_cells_{edge}$

			$r \gets right\_cells_{edge}$

			$pollution_{l} -= \frac{\Delta{u}}{A_{l}}$

			\If {$\exists Cells_{r}$}

				$pollution_{r} \gets \frac{\Delta{u}}{A_{r}}$
			\EndIf
		\EndFor
	\end{alg}

	\caption{Original \update function}
	\label{alg:update}
\end{figure}



There is also the possibility to output the current state of the mesh after every $X$ of iterations, where $X$ is a parameter provided at runtime. This feature allows the output to contain not only the final state of the system byt all the intermediary states, allowing  an animation to be shown using \texttt{gmsh}.

\input{report/311-simplifications}
