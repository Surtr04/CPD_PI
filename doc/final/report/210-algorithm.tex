\subsection{Algorithm}


The algorithm used by the \texttt{polu} consists on a computation stage, where all the required elements are loaded and prepared, and two computation stages, composing the main loop.

Operations performed in the preparation stage are highly dependent on the implementation being described, as most will require some elements to be properly organized or some values to be previously computed. Common operations, such as loading the mesh, the initial polution state and the velocities vector are constant to every implementation, but they may still differ in the structures used to store the data.

A single execution of the two computation stages together form a step in the iterative method behind this application. These stages, also referred in this document as core functions, are the \texttt{compute\_flux} and \texttt{update} functions.

In \texttt{compute\_flux}, all the edges in the mesh are analyzed, and the flux of polution to be moved across that edge is computed, based on the polution level and the velocity vectors of the cells it connects. A preconfigured value is used as the Dirichlet condition, which replaces the polution level of a second cell for the edges in the border of the mesh.

As for the \texttt{update} function, it uses the computed flux values to update the polution levels of each cell in the mesh, by adding the individual contribution of each edge of the cell. While triangular cells are prefered, there are no restrictions to the number of edges a cell may have.

The access patterns of the core functions make this algorithm a typical case of a stencil computation. In terms of performance, this implies the number of operations per accessed byte will most likely remain constant with larger problem sizes.
\todo[inline,color=red!40]{Review this last part.}
\todo[inline,color=red!40]{Might be useful to explain how parallelism is made with common stencils, so their dreams can be crushed in the next subsection. Either here or at the beginning of the next subsection.}
