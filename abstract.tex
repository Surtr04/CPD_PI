\documentclass[9pt,twocolumn]{scrartcl}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

%\usepackage{graphics}%	images other than eps

\usepackage[paper=a4paper,top=2cm,left=1.5cm,right=1.5cm,bottom=2cm,foot=1cm]{geometry}

\usepackage{relsize}%	relative font sizes

%\usepackage[retainorgcmds]{IEEtrantools}%	IEEEeqnarray

\usepackage{hyperref}

%%%%%%%%%%%%%%%%
%  title page  %
%%%%%%%%%%%%%%%%
\titlehead{Universidade do Minho \hfill Parallel and Distributed Computing\\	Master's Degree in Informatics Engineering}

\title{Profiling + CUDA}

\subtitle{A finite volume case study from an industrial application\\(Extended Abstract)}%	TODO รณ Naps, did lรก o nome dest a merda!!

\author{Miguel Palhas \hfill--- \texttt{\smaller pg19808@alunos.uminho.pt}\\Pedro Costa \hfill--- \texttt{\smaller pg19830@alunos.uminho.pt}}

\date{Braga, January 2012}

\subject{Integrated Project}


%%%%%%%%%%%
%  Hacks  %
%%%%%%%%%%%

%	Paragraph with linebreak
\newcommand{\paragraphh}[1]{\paragraph{#1\hfill}\hfill

}


\begin{document}
\maketitle

\section{Introduction}
\subsection{Contextualization}
The Finite Volumes Method (FVM) is one of the three classical choices for solving PDEs\footnote{Partial Differential Equations: equations involving functions with more than one variable and their partial derivatives.} numerically, together with the Finite Difference Method (FDM) and the Finite Element Method (FEM).

The FDM is the oldest method and is based in the classical formal definition of a function's derivative in order to a parameter $x$ as the limit of that function's average rate as the difference between the two points tends towards zero ($\Delta x \rightarrow 0$).

%$${\left . u_{x} \right |}_{i} = u_{x} \left ( x_{i} \right ) = \lim_{\Delta x \rightarrow 0}{\frac{u \left ( x_{i} + \Delta x \right ) - u \left ( x_{i} \right )}{\Delta x}}$$

Even if $\Delta x$ is not constant throughout the mesh, this forces the need for it to be structured on the FDM. The FEM and FVM overcome this by discretizing based on the integral form of the governing equations, therefore being able to handle complex geometries in multi-dimensional problems.

%TODO: FEM

%TODO: FVM

%TODO: fluids mechanics & pollution spreading

\subsection{Motivation}% what we intend to achieve
This document analyzes an application which computes the evolution of a pollutant in a given environment, studying possibilities of optimization and/or parallelization.

Two attempts of parallelization are intended: one using shared memory on a multiprocessor system and one using a GPU.

The final aim is to have a qualitative and quantitive comparison of both versions against each other and the original sequential code, and an evaluation of possible bottlenecks and/or optimizable code parts.

\subsection{Structure}% what will we do (list of actions), a.k.a. structure
The initial profiling of the application, including the methodology and conclusions, is presented in \autoref{sec:initprof}. In \autoref{sec:optm&para}, the initial profiling information is used to identify the parts of the algorithm/code which are better suited for optimization and/or parallelization. The implementation of a shared memory parallel version and a GPU version are explained in \autoref{sec:openmp}  and \autoref{sec:cuda}, respectively.

\section{Sequential}% why did we choose compute_flux & update to mess with
\label{sec:initprof}
The analysis of the sequential code starts with the generation of it's callgraph, from which it is possible to find the function where the program execution spends most of it's time. According to Amdahl's Law, this function should be the first to study for optimizations and/or parallelization, as it's where one can profit the most from speedup.

For the purpose of generating the call graph, the \texttt{Callgrind} tool\footnote{From the Valgrind suite.} was used. The information generated by this tool could then be visualized using \texttt{KCachegrind}.

This reported% values values

\section{Optimization \& Parallelization}
\label{sec:optm&para}
As determined in \autoref{sec:initprof}, the best targets for optimization and/or parallelization are the \texttt{compute\_flux} and \texttt{update} functions, which will be the primary and secondary goals for this project, respectively (each parallelized version will be focusing on these functions by this order).

\subsection{Dependecies}
In the \texttt{compute\_flux} function code one can easily find a data dependency which prevents parallelization. This dependency is found in the calculation of $\Delta t_{i}$ (the final value $\Delta t_{n}$ is returned by the function) and causes each iteration to depend on the previous one (the first iteration uses a preset value $\Delta t_{0}$).

Using mathematical operations this calculation can be removed from the loop and the dependence substituted by a calculation of the maximum computed velocity ($v_{max}$), which can be computed through reduction.

The \texttt{update} function also holds a data dependency between some iterations. This function iterates through every edge, changing the pollution values in every cell based on the computed velocity value of each of it's edges. Since any cell has more than one edge and the final value in a cell is the sum of the contributions from all it's edges, the value can be changed in more than one iteration.

It's possible to remove this dependency by changing the loop itself to iterate over each cell calculating the final value from all it's edges. Considering that no edge data is changed, this completely removes de dependency and allows the parallelization of the function.

\section{OpenMP}
\label{sec:openmp}
\subsection{Implementation}
\subsubsection{Flux Computation}
\paragraphh{\texttt{max} reduction}
coisas
\subsection{Profiling}
\subsubsection{PAPI framework}% why doesn't PAPI have class in the source FFS
\subsubsection{Methodology}% scripts are cool, talk about them

\section{CUDA}
\label{sec:cuda}
\subsection{Data Structures}
\subsection{Implementation}
\subsubsection{Flux Computation}
\paragraphh{\texttt{max} reduction}
\subsubsection{Mesh Update}

\section{Conclusion}
\subsection{Future Work}
%	OpenMP:	update, structures
%	remake FVLib as a proper programmer with a brain would know how


%	Side Notes: OpenFVM.sourceforge.net

\end{document}